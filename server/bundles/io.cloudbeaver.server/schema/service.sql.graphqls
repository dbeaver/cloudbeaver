####################################################
# SQL helpers
####################################################

type SQLDialectInfo {
    name: String!

    dataTypes: [ String ]!
    functions: [ String ]!
    reservedWords: [ String ]!
    quoteStrings: [ [ String ] ]!
    singleLineComments: [ String ]!
    multiLineComments: [ [ String ] ]!

    catalogSeparator: String
    structSeparator: String
    scriptDelimiter: String

    supportsExplainExecutionPlan: Boolean!

}

type SQLCompletionProposal {
    displayString: String!
    type: String!
    score: Int

    replacementString: String!
    replacementOffset: Int!
    replacementLength: Int!
    cursorPosition: Int

    icon: String
    nodePath: String
}

####################################################
# Data read / SQL execution
####################################################

# SQL context must be created for each SQL editor
type SQLContextInfo {

    id: ID!
    projectId: ID!
    connectionId: ID!
    defaultCatalog: String
    defaultSchema: String

}

input SQLDataFilterConstraint {
    attributePosition: Int!
    orderPosition: Int
    orderAsc: Boolean

    criteria: String
    operator: String
    value: Object
}

input SQLDataFilter {
    # Row offset. We use Float because offset may be bigger than 32 bit.
    offset: Float
    limit: Int

    constraints: [ SQLDataFilterConstraint ]
    where: String
    orderBy: String
}

type SQLResultColumn {
    position: Int!
    name: String
    label: String
    icon: String
    entityName: String

    dataKind: String
    typeName: String
    fullTypeName: String
    # Column value max length. We use Float because it may be bigger than 32 bit.
    maxLength: Float
    scale: Int
    precision: Int

    required: Boolean!

    readOnly: Boolean!
    readOnlyStatus: String

    # Operations supported for this attribute
    supportedOperations: [DataTypeLogicalOperation!]!
}

type DatabaseDocument {
    id: String
    contentType: String
    properties: Object
    data: Object
}

type SQLResultSet {
    id: ID!
    columns: [ SQLResultColumn ]
    rows: [ [ Object ] ]

    # True means that resultset was generated by single entity query
    # New rows can be added, old rows can be deleted
    singleEntity: Boolean!
    # server always returns hasMoreData = false
    hasMoreData: Boolean!
    # can't update data or load LOB file if hasRowIdentifier = false
    hasRowIdentifier: Boolean!
}

type SQLQueryResults {
    title: String
    updateRowCount: Float
    sourceQuery: String

    # Actual data format of this result
    dataFormat: ResultDataFormat

    resultSet: SQLResultSet
}

type SQLExecuteInfo {

    # Status message
    statusMessage: String
    # Execute time (ms)
    duration: Int!
    # Actual conditions applied to query
    filterText: String
#    # original sql query without SQLDataFilter
#    originalQuery: String
    # Full query that was executed, contains all used filters
    fullQuery: String
    # Results
    results: [ SQLQueryResults! ]!
}

input SQLResultRow {
    data: [ Object ]!
    updateValues: Object
}

type DataTypeLogicalOperation {
    id: ID!
    expression: String!
    argumentCount: Int
}

####################################################
# SQL Execution plan
####################################################

type SQLExecutionPlan {
    query: String!
    nodes: [SQLExecutionPlanNode!]!
}

type SQLExecutionPlanNode {
    id: ID!
    parentId: ID

    kind: String!
    name: String
    type: String!
    condition: String
    description: String
    properties: [ObjectPropertyInfo!]!
}

####################################################
# SQL Generation
####################################################

type SQLQueryGenerator {
    id: String!
    label: String!
    description: String
    order: Int!
    multiObject: Boolean!
}

####################################################
# SQL Query info
####################################################
type SQLScriptInfo {
    queries: [ SQLScriptQuery! ]!
}

type SQLScriptQuery {
    start: Int!
    end: Int!
}
####################################################
# Query and Mutation
####################################################

extend type Query {

    sqlDialectInfo( projectId: ID, connectionId: ID! ): SQLDialectInfo

    # Lists SQL contexts for a connection (optional) or returns the particular context info
    sqlListContexts( projectId: ID, connectionId: ID, contextId: ID ): [ SQLContextInfo ]!

    sqlCompletionProposals(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        query: String!,
        position: Int!,
        maxResults: Int,
        simpleMode: Boolean
    ): [ SQLCompletionProposal ]

    sqlFormatQuery(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        query: String!
    ): String!

    sqlSupportedOperations(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,
        attributeIndex: Int!
    ): [DataTypeLogicalOperation!]!

    # List of all available entity query generators
    sqlEntityQueryGenerators(nodePathList: [String!]!
    ): [SQLQueryGenerator!]!

    # Options:
    # fullyQualifiedNames: Boolean
    # compactSQL: Boolean
    # showComments: Boolean
    # showPermissions: Boolean
    # showFullDdl: Boolean
    # excludeAutoGeneratedColumn: Boolean
    # useCustomDataFormat: Boolean
    sqlGenerateEntityQuery(
        generatorId: String!,
        options: Object!,
        nodePathList: [String!]!
    ): String!

    sqlParseScript(
        projectId: ID,
        connectionId: ID!,
        script: String!
    ): SQLScriptInfo!

    sqlParseQuery(
        projectId: ID,
        connectionId: ID!,
        script: String!,
        position: Int!
    ): SQLScriptQuery!
}

extend type Mutation {
    sqlContextCreate( projectId: ID, connectionId: ID!, defaultCatalog: String, defaultSchema: String ): SQLContextInfo!

    sqlContextSetDefaults( projectId: ID, connectionId: ID!, contextId: ID!, defaultCatalog: ID, defaultSchema: ID ): Boolean!

    sqlContextDestroy( projectId: ID, connectionId: ID!, contextId: ID! ): Boolean!

    # Execute SQL and return results
    asyncSqlExecuteQuery(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        sql: String!,
        resultId: ID,
        filter: SQLDataFilter,
        dataFormat: ResultDataFormat    # requested data format. May be ignored by server
    ): AsyncTaskInfo!

    # Read data from table
    asyncReadDataFromContainer(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        containerNodePath: ID!,
        resultId: ID,
        filter: SQLDataFilter,
        dataFormat: ResultDataFormat
    ): AsyncTaskInfo!

    # Close results (free resources)
    sqlResultClose(projectId: ID, connectionId: ID!, contextId: ID!, resultId: ID!): Boolean!

    # Update multiple cell values
    updateResultsDataBatch(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,

        updatedRows: [ SQLResultRow! ],
        deletedRows: [ SQLResultRow! ],
        addedRows: [ SQLResultRow! ],
    ): SQLExecuteInfo!

    # Return SQL script for cell values update
    updateResultsDataBatchScript(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,

        updatedRows: [ SQLResultRow! ],
        deletedRows: [ SQLResultRow! ],
        addedRows: [ SQLResultRow! ],
    ): String!

    #Return BLOB name
    readLobValue(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        resultsId: ID!,
        lobColumnIndex: Int!,
        row: [ SQLResultRow! ]!
    ): String!

    # Returns SQLExecuteInfo
    asyncSqlExecuteResults(taskId: ID!): SQLExecuteInfo !

    # Read data from table
    asyncSqlExplainExecutionPlan(
        projectId: ID,
        connectionId: ID!,
        contextId: ID!,
        query: String!,
        configuration: Object!
    ): AsyncTaskInfo!

    # Returns SQLExecutionPlan
    asyncSqlExplainExecutionPlanResult(taskId: ID!): SQLExecutionPlan !

}
